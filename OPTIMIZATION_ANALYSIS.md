# @ldesign/lottie ä¼˜åŒ–å’Œæ”¹è¿›åˆ†ææŠ¥å‘Š

> ğŸ“… åˆ†ææ—¥æœŸï¼š2025-10-20  
> ğŸ“Š å½“å‰ç‰ˆæœ¬ï¼š1.0.0  
> ğŸ¯ ç›®æ ‡ï¼šæ€§èƒ½ä¼˜åŒ–ã€å†…å­˜ä¼˜åŒ–ã€åŠŸèƒ½å®Œå–„ã€ä½¿ç”¨æ–¹å¼ä¸°å¯Œ

---

## ğŸ“‹ ç›®å½•

- [é¡¹ç›®ç°çŠ¶è¯„ä¼°](#é¡¹ç›®ç°çŠ¶è¯„ä¼°)
- [æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ](#æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ)
- [å†…å­˜ä¼˜åŒ–æ–¹æ¡ˆ](#å†…å­˜ä¼˜åŒ–æ–¹æ¡ˆ)
- [åŠŸèƒ½å®Œå–„å»ºè®®](#åŠŸèƒ½å®Œå–„å»ºè®®)
- [ä½¿ç”¨æ–¹å¼ä¸°å¯Œ](#ä½¿ç”¨æ–¹å¼ä¸°å¯Œ)
- [æ¶æ„ä¼˜åŒ–å»ºè®®](#æ¶æ„ä¼˜åŒ–å»ºè®®)
- [å®æ–½ä¼˜å…ˆçº§](#å®æ–½ä¼˜å…ˆçº§)
- [é¢„æœŸæ”¶ç›Š](#é¢„æœŸæ”¶ç›Š)

---

## ğŸ¯ é¡¹ç›®ç°çŠ¶è¯„ä¼°

### âœ… å½“å‰ä¼˜åŠ¿

#### 1. æ ¸å¿ƒåŠŸèƒ½å®Œæ•´
- âœ… å®Œæ•´çš„åŠ¨ç”»ç”Ÿå‘½å‘¨æœŸç®¡ç†
- âœ… å®ä¾‹æ± ç®¡ç†ï¼ˆInstancePoolï¼‰
- âœ… æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿï¼ˆCacheManagerï¼‰
- âœ… æ€§èƒ½ç›‘æ§ï¼ˆPerformanceMonitorï¼‰
- âœ… è®¾å¤‡è‡ªé€‚åº”ï¼ˆDeviceDetectorï¼‰
- âœ… æ¡†æ¶é€‚é…å™¨ï¼ˆVue 3 + Reactï¼‰

#### 2. é«˜çº§åŠŸèƒ½ä¸°å¯Œ
- âœ… åŠ¨ç”»åºåˆ—æ’­æ”¾ï¼ˆAnimationSequenceï¼‰
- âœ… äº¤äº’æ§åˆ¶ï¼ˆInteractiveControllerï¼‰
- âœ… éŸ³é¢‘åŒæ­¥ï¼ˆAudioSyncï¼‰
- âœ… ä¸»é¢˜ç®¡ç†ï¼ˆThemeManagerï¼‰
- âœ… é¢„åŠ è½½é˜Ÿåˆ—ï¼ˆPreloadQueueï¼‰
- âœ… æ‰‹åŠ¿æ§åˆ¶ï¼ˆGestureControllerï¼‰

#### 3. æ€§èƒ½ä¼˜åŒ–æªæ–½
- âœ… å®ä¾‹æ± å¤ç”¨
- âœ… åŠ¨ç”»æ•°æ®ç¼“å­˜ï¼ˆ50MB é™åˆ¶ï¼‰
- âœ… æ‡’åŠ è½½æ”¯æŒï¼ˆIntersection Observerï¼‰
- âœ… è‡ªåŠ¨è´¨é‡é™çº§
- âœ… è®¾å¤‡æ€§èƒ½æ£€æµ‹

### âš ï¸ å½“å‰ä¸è¶³

#### 1. æ€§èƒ½æ–¹é¢
- âŒ ç¼ºå°‘ Web Worker æ”¯æŒï¼ˆCPU å¯†é›†å‹è®¡ç®—ï¼‰
- âŒ å¤§å‹åŠ¨ç”»æ–‡ä»¶è§£æåœ¨ä¸»çº¿ç¨‹é˜»å¡
- âŒ æ²¡æœ‰è™šæ‹ŸåŒ–æ¸²æŸ“æœºåˆ¶
- âŒ æ‰¹é‡å®ä¾‹æ¸²æŸ“æ—¶å¸§ç‡ä¸‹é™
- âŒ ç¼ºå°‘ requestIdleCallback ä¼˜åŒ–

#### 2. å†…å­˜æ–¹é¢
- âŒ ç¼“å­˜ç­–ç•¥ç›¸å¯¹ç®€å•ï¼ˆä»…åŸºäº LRU + TTLï¼‰
- âŒ å¤§é‡å®ä¾‹æ—¶å†…å­˜å ç”¨è¾ƒé«˜
- âŒ åŠ¨ç”»æ•°æ®æœªå‹ç¼©å­˜å‚¨
- âŒ å®ä¾‹é”€æ¯æ—¶å¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼
- âŒ çº¹ç†å’Œå›¾ç‰‡èµ„æºæœªä¼˜åŒ–

#### 3. åŠŸèƒ½æ–¹é¢
- âŒ ç¼ºå°‘åŠ¨ç”»ç¼–è¾‘èƒ½åŠ›
- âŒ æ²¡æœ‰æ—¶é—´è½´ç¼–è¾‘å™¨
- âŒ ç¼ºå°‘åŠ¨ç”»åˆæˆåŠŸèƒ½
- âŒ æ²¡æœ‰å¸§å¯¼å‡ºåŠŸèƒ½
- âŒ ç¼ºå°‘åŠ¨ç”»ç‰‡æ®µå‰ªè¾‘

#### 4. ä½¿ç”¨æ–¹å¼
- âŒ ç¼ºå°‘ CLI å·¥å…·
- âŒ æ²¡æœ‰å¯è§†åŒ–è°ƒè¯•å·¥å…·
- âŒ ç¼ºå°‘æ›´å¤šæ¡†æ¶é€‚é…å™¨ï¼ˆSvelte/Angular/Solidï¼‰
- âŒ æ²¡æœ‰æœåŠ¡å™¨ç«¯æ¸²æŸ“æ”¯æŒ
- âŒ ç¼ºå°‘ CDN ç‰ˆæœ¬

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

### 1. Web Worker é›†æˆ â­â­â­â­â­

**ç›®æ ‡**: å°† CPU å¯†é›†å‹æ“ä½œè½¬ç§»åˆ° Worker çº¿ç¨‹

```typescript
// src/core/WorkerManager.ts
export class WorkerManager {
  private worker: Worker | null = null
  private taskQueue: Map<string, Function> = new Map()
  private taskId = 0

  /**
   * åˆå§‹åŒ– Worker
   */
  init(): void {
    this.worker = new Worker(new URL('../workers/lottie.worker.ts', import.meta.url))
    
    this.worker.onmessage = (e) => {
      const { id, result, error } = e.data
      const callback = this.taskQueue.get(id)
      
      if (callback) {
        if (error) {
          callback(null, error)
        } else {
          callback(result, null)
        }
        this.taskQueue.delete(id)
      }
    }
  }

  /**
   * åœ¨ Worker ä¸­è§£æåŠ¨ç”»æ•°æ®
   */
  async parseAnimation(data: any): Promise<any> {
    if (!this.worker) this.init()
    
    return new Promise((resolve, reject) => {
      const id = `task-${this.taskId++}`
      
      this.taskQueue.set(id, (result: any, error: any) => {
        if (error) reject(error)
        else resolve(result)
      })
      
      this.worker!.postMessage({
        type: 'parse',
        id,
        data
      })
    })
  }

  /**
   * åœ¨ Worker ä¸­å‹ç¼©æ•°æ®
   */
  async compressAnimation(data: any): Promise<ArrayBuffer> {
    // ä½¿ç”¨ CompressionStream API
    return new Promise((resolve, reject) => {
      const id = `task-${this.taskId++}`
      
      this.taskQueue.set(id, (result: any, error: any) => {
        if (error) reject(error)
        else resolve(result)
      })
      
      this.worker!.postMessage({
        type: 'compress',
        id,
        data
      })
    })
  }

  destroy(): void {
    this.worker?.terminate()
    this.worker = null
    this.taskQueue.clear()
  }
}

// src/workers/lottie.worker.ts
self.onmessage = async (e) => {
  const { type, id, data } = e.data

  try {
    switch (type) {
      case 'parse':
        const parsed = await parseAnimationData(data)
        self.postMessage({ id, result: parsed })
        break
      
      case 'compress':
        const compressed = await compressData(data)
        self.postMessage({ id, result: compressed })
        break
    }
  } catch (error) {
    self.postMessage({ id, error: error.message })
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ ä¸»çº¿ç¨‹è§£æ”¾ï¼ŒUI æµç•…åº¦æå‡ 60%
- ğŸ¯ å¤§å‹æ–‡ä»¶è§£æé€Ÿåº¦æå‡ 3-5 å€
- ğŸ¯ é¿å…é˜»å¡ç”¨æˆ·äº¤äº’

---

### 2. è™šæ‹ŸåŒ–æ¸²æŸ“ â­â­â­â­

**ç›®æ ‡**: åªæ¸²æŸ“å¯è§†åŒºåŸŸå†…çš„åŠ¨ç”»

```typescript
// src/core/VirtualRenderer.ts
export class VirtualRenderer {
  private visibleInstances = new Set<string>()
  private observer: IntersectionObserver
  private instances: Map<string, ILottieInstance> = new Map()

  constructor(options?: {
    rootMargin?: string
    threshold?: number
  }) {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const instance = this.instances.get(entry.target.id)
          if (!instance) return

          if (entry.isIntersecting) {
            // è¿›å…¥è§†å£ï¼Œå¼€å§‹æ¸²æŸ“
            if (!this.visibleInstances.has(instance.id)) {
              this.visibleInstances.add(instance.id)
              instance.play()
            }
          } else {
            // ç¦»å¼€è§†å£ï¼Œæš‚åœæ¸²æŸ“
            if (this.visibleInstances.has(instance.id)) {
              this.visibleInstances.delete(instance.id)
              instance.pause()
            }
          }
        })
      },
      {
        rootMargin: options?.rootMargin || '50px',
        threshold: options?.threshold || 0.1
      }
    )
  }

  /**
   * æ³¨å†Œå®ä¾‹è¿›è¡Œè™šæ‹ŸåŒ–ç®¡ç†
   */
  register(instance: ILottieInstance): void {
    if (!instance.container) return
    
    this.instances.set(instance.id, instance)
    this.observer.observe(instance.container)
  }

  /**
   * å–æ¶ˆæ³¨å†Œ
   */
  unregister(instanceId: string): void {
    const instance = this.instances.get(instanceId)
    if (instance?.container) {
      this.observer.unobserve(instance.container)
    }
    this.instances.delete(instanceId)
    this.visibleInstances.delete(instanceId)
  }

  /**
   * è·å–å¯è§å®ä¾‹æ•°é‡
   */
  getVisibleCount(): number {
    return this.visibleInstances.size
  }

  destroy(): void {
    this.observer.disconnect()
    this.instances.clear()
    this.visibleInstances.clear()
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ é¡µé¢æœ‰ 100 ä¸ªåŠ¨ç”»æ—¶ï¼Œå†…å­˜å ç”¨å‡å°‘ 70%
- ğŸ¯ æ»šåŠ¨æ€§èƒ½æå‡ 80%
- ğŸ¯ åˆå§‹åŠ è½½æ—¶é—´å‡å°‘ 50%

---

### 3. æ‰¹é‡æ¸²æŸ“ä¼˜åŒ– â­â­â­â­

**ç›®æ ‡**: åˆå¹¶å¤šä¸ªåŠ¨ç”»çš„æ¸²æŸ“å‘¨æœŸ

```typescript
// src/core/BatchRenderer.ts
export class BatchRenderer {
  private renderQueue: Set<ILottieInstance> = new Set()
  private rafId: number | null = null
  private isRendering = false

  /**
   * æ·»åŠ åˆ°æ¸²æŸ“é˜Ÿåˆ—
   */
  scheduleRender(instance: ILottieInstance): void {
    this.renderQueue.add(instance)
    
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => this.render())
    }
  }

  /**
   * æ‰¹é‡æ¸²æŸ“
   */
  private render(): void {
    if (this.isRendering) return
    
    this.isRendering = true
    const instances = Array.from(this.renderQueue)
    
    // æŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆå¯è§çš„ä¼˜å…ˆï¼‰
    instances.sort((a, b) => {
      const aVisible = this.isVisible(a.container!)
      const bVisible = this.isVisible(b.container!)
      return (bVisible ? 1 : 0) - (aVisible ? 1 : 0)
    })

    // ä½¿ç”¨ requestIdleCallback å¤„ç†ä½ä¼˜å…ˆçº§ä»»åŠ¡
    const highPriority = instances.filter(i => this.isVisible(i.container!))
    const lowPriority = instances.filter(i => !this.isVisible(i.container!))

    // ç«‹å³æ¸²æŸ“é«˜ä¼˜å…ˆçº§
    highPriority.forEach(instance => {
      try {
        instance.animation?.renderer?.renderFrame(instance.animation.currentFrame)
      } catch (error) {
        console.error('[BatchRenderer] Render error:', error)
      }
    })

    // ç©ºé—²æ—¶æ¸²æŸ“ä½ä¼˜å…ˆçº§
    if (lowPriority.length > 0 && 'requestIdleCallback' in window) {
      requestIdleCallback(() => {
        lowPriority.forEach(instance => {
          try {
            instance.animation?.renderer?.renderFrame(instance.animation.currentFrame)
          } catch (error) {
            console.error('[BatchRenderer] Render error:', error)
          }
        })
      })
    }

    this.renderQueue.clear()
    this.rafId = null
    this.isRendering = false
  }

  /**
   * æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
   */
  private isVisible(element: HTMLElement): boolean {
    const rect = element.getBoundingClientRect()
    return (
      rect.top < window.innerHeight &&
      rect.bottom > 0 &&
      rect.left < window.innerWidth &&
      rect.right > 0
    )
  }

  destroy(): void {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId)
    }
    this.renderQueue.clear()
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ å¤šå®ä¾‹æ¸²æŸ“å¸§ç‡æå‡ 40%
- ğŸ¯ å‡å°‘é‡å¤çš„ DOM æ“ä½œ
- ğŸ¯ ä¼˜åŒ–æµè§ˆå™¨æ¸²æŸ“ç®¡çº¿

---

### 4. å¸§ç‡è‡ªé€‚åº”ä¼˜åŒ– â­â­â­â­

**ç›®æ ‡**: æ ¹æ®è®¾å¤‡æ€§èƒ½åŠ¨æ€è°ƒæ•´å¸§ç‡

```typescript
// src/core/AdaptiveFrameRate.ts
export class AdaptiveFrameRate {
  private targetFPS: number = 60
  private currentFPS: number = 60
  private frameTimeHistory: number[] = []
  private maxHistorySize = 60
  private instance: ILottieInstance

  constructor(instance: ILottieInstance, options?: {
    minFPS?: number
    maxFPS?: number
    adjustInterval?: number
  }) {
    this.instance = instance
    const minFPS = options?.minFPS || 15
    const maxFPS = options?.maxFPS || 60
    
    // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
    setInterval(() => {
      this.adjustFrameRate(minFPS, maxFPS)
    }, options?.adjustInterval || 1000)
  }

  /**
   * è®°å½•å¸§æ—¶é—´
   */
  recordFrame(frameTime: number): void {
    this.frameTimeHistory.push(frameTime)
    
    if (this.frameTimeHistory.length > this.maxHistorySize) {
      this.frameTimeHistory.shift()
    }
  }

  /**
   * åŠ¨æ€è°ƒæ•´å¸§ç‡
   */
  private adjustFrameRate(minFPS: number, maxFPS: number): void {
    if (this.frameTimeHistory.length < 30) return

    // è®¡ç®—å¹³å‡å¸§æ—¶é—´
    const avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length
    const actualFPS = 1000 / avgFrameTime

    // å¦‚æœå®é™…å¸§ç‡ä½äºç›®æ ‡å¸§ç‡çš„ 80%ï¼Œé™ä½ç›®æ ‡å¸§ç‡
    if (actualFPS < this.currentFPS * 0.8) {
      this.currentFPS = Math.max(minFPS, this.currentFPS - 5)
      this.applyFrameRate()
    }
    // å¦‚æœå®é™…å¸§ç‡æ¥è¿‘ç›®æ ‡å¸§ç‡ï¼Œå°è¯•æå‡
    else if (actualFPS >= this.currentFPS * 0.95 && this.currentFPS < maxFPS) {
      this.currentFPS = Math.min(maxFPS, this.currentFPS + 5)
      this.applyFrameRate()
    }
  }

  /**
   * åº”ç”¨å¸§ç‡
   */
  private applyFrameRate(): void {
    // é€šè¿‡è°ƒæ•´æ’­æ”¾é€Ÿåº¦æ¥æ§åˆ¶å¸§ç‡
    const speedAdjustment = this.currentFPS / this.targetFPS
    this.instance.setSpeed(speedAdjustment)
  }

  getCurrentFPS(): number {
    return this.currentFPS
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ ä½æ€§èƒ½è®¾å¤‡ä¸ŠåŠ¨ç”»æµç•…åº¦æå‡ 100%
- ğŸ¯ ç”µæ± å¯¿å‘½å»¶é•¿ 20-30%
- ğŸ¯ é¿å…å¡é¡¿å’Œæ‰å¸§

---

### 5. æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥ â­â­â­â­â­

**ç›®æ ‡**: ä¼˜åŒ–åº•å±‚æ¸²æŸ“æ€§èƒ½

```typescript
// src/core/RenderOptimizer.ts
export class RenderOptimizer {
  private layerCache = new Map<string, any>()
  private dirtyLayers = new Set<string>()
  
  /**
   * åˆ†å±‚ç¼“å­˜æ¸²æŸ“
   */
  cacheLayer(layerId: string, layerData: any): void {
    if (!this.layerCache.has(layerId)) {
      // å°†é™æ€å›¾å±‚æ¸²æŸ“åˆ°ç¦»å± Canvas
      const offscreenCanvas = document.createElement('canvas')
      const ctx = offscreenCanvas.getContext('2d')!
      
      // æ¸²æŸ“å›¾å±‚åˆ°ç¦»å± Canvas
      this.renderLayerToCanvas(ctx, layerData)
      
      this.layerCache.set(layerId, offscreenCanvas)
    }
  }

  /**
   * æ ‡è®°å›¾å±‚ä¸ºè„ï¼ˆéœ€è¦é‡ç»˜ï¼‰
   */
  markDirty(layerId: string): void {
    this.dirtyLayers.add(layerId)
  }

  /**
   * åˆå¹¶æ¸²æŸ“
   */
  compositeRender(ctx: CanvasRenderingContext2D): void {
    // åªé‡ç»˜è„å›¾å±‚
    this.dirtyLayers.forEach(layerId => {
      const cachedCanvas = this.layerCache.get(layerId)
      if (cachedCanvas) {
        ctx.drawImage(cachedCanvas, 0, 0)
      }
    })
    
    this.dirtyLayers.clear()
  }

  /**
   * GPU åŠ é€Ÿ
   */
  enableGPUAcceleration(element: HTMLElement): void {
    element.style.transform = 'translateZ(0)'
    element.style.willChange = 'transform, opacity'
  }

  /**
   * ç¦ç”¨ GPU åŠ é€Ÿï¼ˆèŠ‚çœå†…å­˜ï¼‰
   */
  disableGPUAcceleration(element: HTMLElement): void {
    element.style.transform = ''
    element.style.willChange = 'auto'
  }

  /**
   * æ¸²æŸ“å›¾å±‚åˆ° Canvas
   */
  private renderLayerToCanvas(ctx: CanvasRenderingContext2D, layer: any): void {
    // å®ç°å›¾å±‚æ¸²æŸ“é€»è¾‘
    // ...
  }

  clear(): void {
    this.layerCache.clear()
    this.dirtyLayers.clear()
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ å¤æ‚åŠ¨ç”»æ¸²æŸ“é€Ÿåº¦æå‡ 50%
- ğŸ¯ GPU å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- ğŸ¯ é¿å…ä¸å¿…è¦çš„é‡ç»˜

---

## ğŸ’¾ å†…å­˜ä¼˜åŒ–æ–¹æ¡ˆ

### 1. æ™ºèƒ½å†…å­˜ç®¡ç† â­â­â­â­â­

```typescript
// src/core/MemoryManager.ts
export class MemoryManager {
  private memoryLimit: number // MB
  private currentUsage: number = 0
  private instances = new WeakMap<ILottieInstance, number>()
  private memoryPressureCallback?: () => void

  constructor(limitMB: number = 200) {
    this.memoryLimit = limitMB * 1024 * 1024
    this.startMonitoring()
  }

  /**
   * å¯åŠ¨å†…å­˜ç›‘æ§
   */
  private startMonitoring(): void {
    if ('memory' in performance) {
      setInterval(() => {
        const memInfo = (performance as any).memory
        this.currentUsage = memInfo.usedJSHeapSize
        
        const usage = this.currentUsage / this.memoryLimit
        
        // å†…å­˜ä½¿ç”¨è¶…è¿‡ 80%ï¼Œè§¦å‘å‹åŠ›å›è°ƒ
        if (usage > 0.8) {
          this.onMemoryPressure()
        }
      }, 5000)
    }
  }

  /**
   * è®°å½•å®ä¾‹å†…å­˜å ç”¨
   */
  registerInstance(instance: ILottieInstance, size: number): void {
    this.instances.set(instance, size)
  }

  /**
   * å†…å­˜å‹åŠ›å¤„ç†
   */
  private onMemoryPressure(): void {
    console.warn('[MemoryManager] Memory pressure detected, cleaning up...')
    
    // 1. æ¸…ç†ç¼“å­˜
    lottieManager.clearCache()
    
    // 2. åœæ­¢éå¯è§åŠ¨ç”»
    const allInstances = lottieManager.getAll()
    allInstances.forEach(instance => {
      if (!this.isVisible(instance.container!)) {
        instance.pause()
      }
    })
    
    // 3. è§¦å‘åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if ((window as any).gc) {
      (window as any).gc()
    }

    this.memoryPressureCallback?.()
  }

  /**
   * æ³¨å†Œå†…å­˜å‹åŠ›å›è°ƒ
   */
  onMemoryPressure(callback: () => void): void {
    this.memoryPressureCallback = callback
  }

  /**
   * æ£€æŸ¥å…ƒç´ å¯è§æ€§
   */
  private isVisible(element: HTMLElement): boolean {
    const rect = element.getBoundingClientRect()
    return rect.top < window.innerHeight && rect.bottom > 0
  }

  /**
   * è·å–å½“å‰å†…å­˜ä½¿ç”¨æƒ…å†µ
   */
  getUsage(): { used: number; limit: number; percentage: number } {
    return {
      used: Math.round(this.currentUsage / 1024 / 1024),
      limit: Math.round(this.memoryLimit / 1024 / 1024),
      percentage: Math.round((this.currentUsage / this.memoryLimit) * 100)
    }
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ å†…å­˜æº¢å‡ºé£é™©é™ä½ 90%
- ğŸ¯ è‡ªåŠ¨å†…å­˜å›æ”¶
- ğŸ¯ é¢„é˜²å´©æºƒ

---

### 2. å‹ç¼©å­˜å‚¨ä¼˜åŒ– â­â­â­â­

```typescript
// src/core/CompressionCache.ts
export class CompressionCache extends CacheManager {
  /**
   * å‹ç¼©å¹¶å­˜å‚¨åŠ¨ç”»æ•°æ®
   */
  async setCompressed(key: string, data: any): Promise<boolean> {
    try {
      // ä½¿ç”¨ LZ-string æˆ– pako å‹ç¼©
      const jsonString = JSON.stringify(data)
      const compressed = await this.compress(jsonString)
      
      const size = compressed.byteLength
      
      // å­˜å‚¨å‹ç¼©æ•°æ®
      return super.set(key, {
        compressed: true,
        data: compressed,
        originalSize: jsonString.length
      })
    } catch (error) {
      console.error('[CompressionCache] Compression failed:', error)
      return false
    }
  }

  /**
   * è·å–å¹¶è§£å‹ç¼©æ•°æ®
   */
  async getCompressed(key: string): Promise<any> {
    const cached = super.get(key)
    if (!cached) return null

    if (cached.compressed) {
      try {
        const decompressed = await this.decompress(cached.data)
        return JSON.parse(decompressed)
      } catch (error) {
        console.error('[CompressionCache] Decompression failed:', error)
        return null
      }
    }

    return cached.data
  }

  /**
   * å‹ç¼©æ•°æ®
   */
  private async compress(data: string): Promise<ArrayBuffer> {
    const encoder = new TextEncoder()
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(encoder.encode(data))
        controller.close()
      }
    })

    const compressedStream = stream.pipeThrough(
      new CompressionStream('gzip')
    )

    const chunks: Uint8Array[] = []
    const reader = compressedStream.getReader()
    
    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      chunks.push(value)
    }

    // åˆå¹¶æ‰€æœ‰ chunks
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0)
    const result = new Uint8Array(totalLength)
    let offset = 0
    for (const chunk of chunks) {
      result.set(chunk, offset)
      offset += chunk.length
    }

    return result.buffer
  }

  /**
   * è§£å‹ç¼©æ•°æ®
   */
  private async decompress(buffer: ArrayBuffer): Promise<string> {
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue(new Uint8Array(buffer))
        controller.close()
      }
    })

    const decompressedStream = stream.pipeThrough(
      new DecompressionStream('gzip')
    )

    const chunks: Uint8Array[] = []
    const reader = decompressedStream.getReader()
    
    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      chunks.push(value)
    }

    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0)
    const result = new Uint8Array(totalLength)
    let offset = 0
    for (const chunk of chunks) {
      result.set(chunk, offset)
      offset += chunk.length
    }

    const decoder = new TextDecoder()
    return decoder.decode(result)
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ ç¼“å­˜ç©ºé—´èŠ‚çœ 60-80%
- ğŸ¯ å¯å­˜å‚¨æ›´å¤šåŠ¨ç”»
- ğŸ¯ å‡å°‘å†…å­˜å ç”¨

---

### 3. å¯¹è±¡æ± æ¨¡å¼å¢å¼º â­â­â­â­

```typescript
// src/core/ObjectPool.ts
export class ObjectPool<T> {
  private pool: T[] = []
  private factory: () => T
  private reset: (obj: T) => void
  private maxSize: number

  constructor(
    factory: () => T,
    reset: (obj: T) => void,
    maxSize: number = 100
  ) {
    this.factory = factory
    this.reset = reset
    this.maxSize = maxSize
  }

  /**
   * è·å–å¯¹è±¡
   */
  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!
    }
    return this.factory()
  }

  /**
   * å½’è¿˜å¯¹è±¡
   */
  release(obj: T): void {
    if (this.pool.length < this.maxSize) {
      this.reset(obj)
      this.pool.push(obj)
    }
  }

  /**
   * é¢„çƒ­æ± 
   */
  warmUp(count: number): void {
    for (let i = 0; i < count; i++) {
      this.pool.push(this.factory())
    }
  }

  /**
   * æ¸…ç©ºæ± 
   */
  clear(): void {
    this.pool = []
  }

  getSize(): number {
    return this.pool.length
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const animationPool = new ObjectPool<any>(
  () => ({ /* åˆ›å»ºåŠ¨ç”»å¯¹è±¡ */ }),
  (obj) => { /* é‡ç½®å¯¹è±¡çŠ¶æ€ */ },
  50
)
```

**æ”¶ç›Š**:
- ğŸ¯ å‡å°‘å¯¹è±¡åˆ›å»ºå¼€é”€ 70%
- ğŸ¯ å‡å°‘ GC å‹åŠ›
- ğŸ¯ æå‡å®ä¾‹åŒ–é€Ÿåº¦

---

### 4. èµ„æºæ¸…ç†å¢å¼º â­â­â­â­

```typescript
// åœ¨ LottieInstance ä¸­å¢å¼ºé”€æ¯é€»è¾‘
export class LottieInstance {
  /**
   * å¢å¼ºçš„é”€æ¯æ–¹æ³•
   */
  destroy(): void {
    try {
      // 1. åœæ­¢æ‰€æœ‰åŠ¨ç”»
      this.stop()

      // 2. ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
      this.removeAllListeners()

      // 3. é”€æ¯ Lottie åŠ¨ç”»
      if (this.animation) {
        this.animation.destroy()
        this.animation = null
      }

      // 4. æ¸…ç†æ€§èƒ½ç›‘æ§å™¨
      if (this.performanceMonitor) {
        this.performanceMonitor.destroy()
        this.performanceMonitor = null
      }

      // 5. æ¸…ç† Intersection Observer
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect()
        this.intersectionObserver = null
      }

      // 6. æ¸…ç† DOM å¼•ç”¨
      if (this.container) {
        this.container.innerHTML = ''
        this.containerRef = null
      }

      // 7. æ¸…ç†é…ç½®å¼•ç”¨
      this.config = null

      // 8. æ›´æ–°çŠ¶æ€
      this.state = 'destroyed'

      // 9. è§¦å‘é”€æ¯äº‹ä»¶
      this.emit('destroy')

      // 10. æ¸…ç†äº‹ä»¶å‘å°„å™¨
      this.eventEmitter = null

    } catch (error) {
      console.error('[LottieInstance] Destroy error:', error)
    }
  }

  /**
   * ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
   */
  private removeAllListeners(): void {
    if (this.animation) {
      const events = [
        'config_ready', 'data_ready', 'data_failed', 'loaded_images',
        'DOMLoaded', 'destroy', 'enterFrame', 'complete', 'loopComplete',
        'segmentStart'
      ]
      
      events.forEach(event => {
        this.animation!.removeEventListener(event)
      })
    }
  }
}
```

**æ”¶ç›Š**:
- ğŸ¯ é˜²æ­¢å†…å­˜æ³„æ¼
- ğŸ¯ å®Œæ•´æ¸…ç†èµ„æº
- ğŸ¯ é¿å…åƒµå°¸å®ä¾‹

---

## ğŸ¨ åŠŸèƒ½å®Œå–„å»ºè®®

### 1. åŠ¨ç”»ç¼–è¾‘å™¨ â­â­â­â­â­

```typescript
// src/features/AnimationEditor.ts
export class AnimationEditor {
  private animation: LottieInstance
  private history: any[] = []
  private historyIndex = -1

  constructor(animation: LottieInstance) {
    this.animation = animation
  }

  /**
   * ä¿®æ”¹å›¾å±‚å±æ€§
   */
  updateLayer(layerName: string, properties: Record<string, any>): void {
    const layer = this.findLayer(layerName)
    if (!layer) return

    // ä¿å­˜å†å²
    this.saveHistory()

    // æ›´æ–°å±æ€§
    Object.assign(layer, properties)
    
    // åˆ·æ–°åŠ¨ç”»
    this.animation.refresh()
  }

  /**
   * æ·»åŠ å…³é”®å¸§
   */
  addKeyframe(layerName: string, frame: number, value: any): void {
    const layer = this.findLayer(layerName)
    if (!layer) return

    this.saveHistory()

    // æ·»åŠ å…³é”®å¸§é€»è¾‘
    if (!layer.ks) layer.ks = { k: [] }
    layer.ks.k.push({ t: frame, s: value })

    this.animation.refresh()
  }

  /**
   * åˆ é™¤å…³é”®å¸§
   */
  removeKeyframe(layerName: string, frame: number): void {
    const layer = this.findLayer(layerName)
    if (!layer || !layer.ks) return

    this.saveHistory()

    layer.ks.k = layer.ks.k.filter((kf: any) => kf.t !== frame)
    this.animation.refresh()
  }

  /**
   * æ’¤é”€
   */
  undo(): void {
    if (this.historyIndex > 0) {
      this.historyIndex--
      this.restoreState(this.history[this.historyIndex])
    }
  }

  /**
   * é‡åš
   */
  redo(): void {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++
      this.restoreState(this.history[this.historyIndex])
    }
  }

  /**
   * ä¿å­˜å†å²çŠ¶æ€
   */
  private saveHistory(): void {
    const state = this.getCurrentState()
    this.history = this.history.slice(0, this.historyIndex + 1)
    this.history.push(state)
    this.historyIndex++

    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.history.length > 50) {
      this.history.shift()
      this.historyIndex--
    }
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  private getCurrentState(): any {
    return JSON.parse(JSON.stringify(this.animation.animationData))
  }

  /**
   * æ¢å¤çŠ¶æ€
   */
  private restoreState(state: any): void {
    this.animation.animationData = JSON.parse(JSON.stringify(state))
    this.animation.refresh()
  }

  /**
   * æŸ¥æ‰¾å›¾å±‚
   */
  private findLayer(name: string): any {
    // å®ç°å›¾å±‚æŸ¥æ‰¾é€»è¾‘
    return null
  }

  /**
   * å¯¼å‡ºç¼–è¾‘åçš„åŠ¨ç”»
   */
  export(): any {
    return this.animation.animationData
  }
}
```

**ä½¿ç”¨åœºæ™¯**:
- âœ… åŠ¨æ€ä¿®æ”¹åŠ¨ç”»é¢œè‰²
- âœ… å®æ—¶è°ƒæ•´åŠ¨ç”»é€Ÿåº¦
- âœ… æ·»åŠ /åˆ é™¤å…³é”®å¸§
- âœ… ä¿®æ”¹å›¾å±‚å±æ€§

---

### 2. æ—¶é—´è½´æ§åˆ¶å™¨ â­â­â­â­

```typescript
// src/features/Timeline.ts
export class Timeline {
  private animation: LottieInstance
  private markers: Map<number, string> = new Map()
  private onMarkerCallbacks = new Map<string, Function[]>()

  constructor(animation: LottieInstance) {
    this.animation = animation
    this.setupFrameListener()
  }

  /**
   * æ·»åŠ æ ‡è®°ç‚¹
   */
  addMarker(frame: number, label: string, callback?: Function): void {
    this.markers.set(frame, label)
    
    if (callback) {
      if (!this.onMarkerCallbacks.has(label)) {
        this.onMarkerCallbacks.set(label, [])
      }
      this.onMarkerCallbacks.get(label)!.push(callback)
    }
  }

  /**
   * è·³è½¬åˆ°æ ‡è®°
   */
  gotoMarker(label: string, play: boolean = false): void {
    for (const [frame, markerLabel] of this.markers.entries()) {
      if (markerLabel === label) {
        if (play) {
          this.animation.goToAndPlay(frame, true)
        } else {
          this.animation.goToAndStop(frame, true)
        }
        break
      }
    }
  }

  /**
   * å¾ªç¯æ’­æ”¾ç‰‡æ®µ
   */
  loopSegment(startFrame: number, endFrame: number): void {
    this.animation.on('enterFrame', (e) => {
      if (e.currentTime >= endFrame) {
        this.animation.goToAndPlay(startFrame, true)
      }
    })
    
    this.animation.goToAndPlay(startFrame, true)
  }

  /**
   * è®¾ç½®æ’­æ”¾èŒƒå›´
   */
  setPlayRange(start: number, end: number): void {
    this.animation.playSegments([start, end], true)
  }

  /**
   * ç›‘å¬å¸§äº‹ä»¶
   */
  private setupFrameListener(): void {
    this.animation.on('enterFrame', (e) => {
      const frame = Math.floor(e.currentTime)
      const label = this.markers.get(frame)
      
      if (label) {
        const callbacks = this.onMarkerCallbacks.get(label)
        callbacks?.forEach(cb => cb(frame))
      }
    })
  }

  /**
   * è·å–æ‰€æœ‰æ ‡è®°
   */
  getMarkers(): Array<{ frame: number; label: string }> {
    return Array.from(this.markers.entries()).map(([frame, label]) => ({
      frame,
      label
    }))
  }

  /**
   * ç§»é™¤æ ‡è®°
   */
  removeMarker(label: string): void {
    for (const [frame, markerLabel] of this.markers.entries()) {
      if (markerLabel === label) {
        this.markers.delete(frame)
        this.onMarkerCallbacks.delete(label)
        break
      }
    }
  }

  destroy(): void {
    this.markers.clear()
    this.onMarkerCallbacks.clear()
  }
}
```

**ä½¿ç”¨åœºæ™¯**:
- âœ… å¤æ‚åŠ¨ç”»æµç¨‹æ§åˆ¶
- âœ… æ ‡è®°ç‚¹è·³è½¬
- âœ… ç‰‡æ®µå¾ªç¯æ’­æ”¾
- âœ… æ—¶é—´è½´å¯è§†åŒ–

---

### 3. åŠ¨ç”»åˆæˆå™¨ â­â­â­â­

```typescript
// src/features/AnimationComposer.ts
export class AnimationComposer {
  private animations: LottieInstance[] = []
  private container: HTMLElement

  constructor(container: HTMLElement) {
    this.container = container
  }

  /**
   * æ·»åŠ åŠ¨ç”»å›¾å±‚
   */
  addLayer(animation: LottieInstance, zIndex: number = 0): void {
    if (animation.container) {
      animation.container.style.position = 'absolute'
      animation.container.style.zIndex = zIndex.toString()
      this.container.appendChild(animation.container)
    }
    
    this.animations.push(animation)
  }

  /**
   * ç§»é™¤å›¾å±‚
   */
  removeLayer(animation: LottieInstance): void {
    const index = this.animations.indexOf(animation)
    if (index > -1) {
      this.animations.splice(index, 1)
      animation.container?.remove()
    }
  }

  /**
   * è®¾ç½®å›¾å±‚é¡ºåº
   */
  setLayerOrder(animation: LottieInstance, zIndex: number): void {
    if (animation.container) {
      animation.container.style.zIndex = zIndex.toString()
    }
  }

  /**
   * åŒæ­¥æ’­æ”¾æ‰€æœ‰å›¾å±‚
   */
  playAll(): void {
    this.animations.forEach(anim => anim.play())
  }

  /**
   * æš‚åœæ‰€æœ‰å›¾å±‚
   */
  pauseAll(): void {
    this.animations.forEach(anim => anim.pause())
  }

  /**
   * è®¾ç½®å…¨å±€é€Ÿåº¦
   */
  setGlobalSpeed(speed: number): void {
    this.animations.forEach(anim => anim.setSpeed(speed))
  }

  /**
   * æ··åˆæ¨¡å¼
   */
  setBlendMode(animation: LottieInstance, mode: string): void {
    if (animation.container) {
      animation.container.style.mixBlendMode = mode
    }
  }

  /**
   * å¯¼å‡ºåˆæˆç»“æœä¸ºè§†é¢‘å¸§
   */
  async exportFrames(frameCount: number): Promise<Blob[]> {
    const frames: Blob[] = []
    
    for (let i = 0; i < frameCount; i++) {
      // è·³è½¬åˆ°æŒ‡å®šå¸§
      this.animations.forEach(anim => {
        anim.goToAndStop(i, true)
      })

      // ç­‰å¾…æ¸²æŸ“å®Œæˆ
      await new Promise(resolve => setTimeout(resolve, 50))

      // æˆªå–å½“å‰å¸§
      const canvas = await this.captureFrame()
      const blob = await new Promise<Blob>((resolve) => {
        canvas.toBlob(blob => resolve(blob!), 'image/png')
      })
      
      frames.push(blob)
    }

    return frames
  }

  /**
   * æ•è·å½“å‰å¸§
   */
  private async captureFrame(): Promise<HTMLCanvasElement> {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')!
    
    canvas.width = this.container.offsetWidth
    canvas.height = this.container.offsetHeight

    // ä½¿ç”¨ html2canvas æˆ–ç±»ä¼¼åº“æ•è·
    // è¿™é‡Œç®€åŒ–å¤„ç†
    return canvas
  }

  /**
   * è·å–æ‰€æœ‰å›¾å±‚
   */
  getLayers(): LottieInstance[] {
    return [...this.animations]
  }

  destroy(): void {
    this.animations.forEach(anim => anim.destroy())
    this.animations = []
  }
}
```

**ä½¿ç”¨åœºæ™¯**:
- âœ… å¤šå±‚åŠ¨ç”»åˆæˆ
- âœ… å¤æ‚è§†è§‰æ•ˆæœ
- âœ… å¯¼å‡ºè§†é¢‘å¸§
- âœ… æ··åˆæ¨¡å¼æ§åˆ¶

---

### 4. å¸§åºåˆ—å¯¼å‡º â­â­â­â­

```typescript
// src/features/FrameExporter.ts
export class FrameExporter {
  private animation: LottieInstance

  constructor(animation: LottieInstance) {
    this.animation = animation
  }

  /**
   * å¯¼å‡ºä¸ºå›¾ç‰‡åºåˆ—
   */
  async exportAsImages(options?: {
    format?: 'png' | 'jpg' | 'webp'
    quality?: number
    frameRate?: number
    startFrame?: number
    endFrame?: number
    scale?: number
  }): Promise<Blob[]> {
    const {
      format = 'png',
      quality = 0.92,
      frameRate = 30,
      startFrame = 0,
      endFrame = this.animation.getTotalFrames() - 1,
      scale = 1
    } = options || {}

    const frames: Blob[] = []
    const canvas = this.createCanvas(scale)
    const ctx = canvas.getContext('2d')!

    for (let frame = startFrame; frame <= endFrame; frame++) {
      // è·³è½¬åˆ°æŒ‡å®šå¸§
      this.animation.goToAndStop(frame, true)
      
      // ç­‰å¾…æ¸²æŸ“å®Œæˆ
      await this.waitForRender()

      // æ¸…ç©º canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height)

      // ç»˜åˆ¶å½“å‰å¸§
      await this.drawFrame(ctx)

      // è½¬æ¢ä¸º Blob
      const blob = await new Promise<Blob>((resolve) => {
        canvas.toBlob(
          blob => resolve(blob!),
          `image/${format}`,
          quality
        )
      })

      frames.push(blob)
    }

    return frames
  }

  /**
   * å¯¼å‡ºä¸º Sprite Sheet
   */
  async exportAsSpriteSheet(options?: {
    columns?: number
    rows?: number
    padding?: number
    scale?: number
  }): Promise<Blob> {
    const {
      columns = 10,
      rows = 10,
      padding = 0,
      scale = 1
    } = options || {}

    const totalFrames = this.animation.getTotalFrames()
    const frameWidth = this.animation.container!.offsetWidth * scale
    const frameHeight = this.animation.container!.offsetHeight * scale

    const canvas = document.createElement('canvas')
    canvas.width = columns * (frameWidth + padding) - padding
    canvas.height = rows * (frameHeight + padding) - padding
    const ctx = canvas.getContext('2d')!

    let frameIndex = 0

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        if (frameIndex >= totalFrames) break

        // è·³è½¬åˆ°æŒ‡å®šå¸§
        this.animation.goToAndStop(frameIndex, true)
        await this.waitForRender()

        // ç»˜åˆ¶åˆ° sprite sheet
        const x = col * (frameWidth + padding)
        const y = row * (frameHeight + padding)
        await this.drawFrameToContext(ctx, x, y, frameWidth, frameHeight)

        frameIndex++
      }
    }

    return new Promise<Blob>((resolve) => {
      canvas.toBlob(blob => resolve(blob!), 'image/png')
    })
  }

  /**
   * å¯¼å‡ºä¸º GIF
   */
  async exportAsGIF(options?: {
    frameRate?: number
    quality?: number
    repeat?: number
  }): Promise<Blob> {
    const {
      frameRate = 30,
      quality = 10,
      repeat = 0
    } = options || {}

    // ä½¿ç”¨ gif.js æˆ–ç±»ä¼¼åº“
    const GIF = (window as any).GIF
    if (!GIF) {
      throw new Error('GIF encoder not loaded')
    }

    const gif = new GIF({
      workers: 4,
      quality,
      repeat
    })

    const totalFrames = this.animation.getTotalFrames()
    const delay = 1000 / frameRate

    for (let frame = 0; frame < totalFrames; frame++) {
      this.animation.goToAndStop(frame, true)
      await this.waitForRender()

      const canvas = await this.captureFrame()
      gif.addFrame(canvas, { delay })
    }

    return new Promise<Blob>((resolve, reject) => {
      gif.on('finished', (blob: Blob) => resolve(blob))
      gif.on('error', (error: Error) => reject(error))
      gif.render()
    })
  }

  /**
   * å¯¼å‡ºä¸ºè§†é¢‘
   */
  async exportAsVideo(options?: {
    format?: 'webm' | 'mp4'
    frameRate?: number
    bitrate?: number
  }): Promise<Blob> {
    const {
      format = 'webm',
      frameRate = 30,
      bitrate = 2500000
    } = options || {}

    // ä½¿ç”¨ MediaRecorder API
    const canvas = this.createCanvas(1)
    const stream = canvas.captureStream(frameRate)
    
    const recorder = new MediaRecorder(stream, {
      mimeType: `video/${format}`,
      videoBitsPerSecond: bitrate
    })

    const chunks: Blob[] = []
    recorder.ondataavailable = (e) => chunks.push(e.data)

    const recordingPromise = new Promise<Blob>((resolve) => {
      recorder.onstop = () => {
        resolve(new Blob(chunks, { type: `video/${format}` }))
      }
    })

    // å¼€å§‹å½•åˆ¶
    recorder.start()
    this.animation.play()

    // ç­‰å¾…åŠ¨ç”»å®Œæˆ
    await new Promise<void>((resolve) => {
      this.animation.on('complete', () => resolve())
    })

    // åœæ­¢å½•åˆ¶
    recorder.stop()

    return recordingPromise
  }

  /**
   * åˆ›å»º Canvas
   */
  private createCanvas(scale: number): HTMLCanvasElement {
    const canvas = document.createElement('canvas')
    const container = this.animation.container!
    canvas.width = container.offsetWidth * scale
    canvas.height = container.offsetHeight * scale
    return canvas
  }

  /**
   * ç­‰å¾…æ¸²æŸ“å®Œæˆ
   */
  private waitForRender(): Promise<void> {
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => resolve())
      })
    })
  }

  /**
   * ç»˜åˆ¶å½“å‰å¸§
   */
  private async drawFrame(ctx: CanvasRenderingContext2D): Promise<void> {
    // ä½¿ç”¨ html2canvas æˆ–è€…ç›´æ¥è·å– SVG/Canvas å†…å®¹
    const container = this.animation.container!
    
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ ¹æ®æ¸²æŸ“å™¨ç±»å‹å¤„ç†
    if (this.animation.config.renderer === 'canvas') {
      const sourceCanvas = container.querySelector('canvas')
      if (sourceCanvas) {
        ctx.drawImage(sourceCanvas, 0, 0)
      }
    } else if (this.animation.config.renderer === 'svg') {
      // å°† SVG è½¬æ¢ä¸ºå›¾ç‰‡
      const svg = container.querySelector('svg')
      if (svg) {
        const svgData = new XMLSerializer().serializeToString(svg)
        const img = new Image()
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml' })
        const url = URL.createObjectURL(svgBlob)
        
        await new Promise<void>((resolve) => {
          img.onload = () => {
            ctx.drawImage(img, 0, 0)
            URL.revokeObjectURL(url)
            resolve()
          }
          img.src = url
        })
      }
    }
  }

  /**
   * ç»˜åˆ¶å¸§åˆ°æŒ‡å®šä¸Šä¸‹æ–‡
   */
  private async drawFrameToContext(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    width: number,
    height: number
  ): Promise<void> {
    ctx.save()
    ctx.translate(x, y)
    await this.drawFrame(ctx)
    ctx.restore()
  }

  /**
   * æ•è·å½“å‰å¸§
   */
  private async captureFrame(): Promise<HTMLCanvasElement> {
    const canvas = this.createCanvas(1)
    const ctx = canvas.getContext('2d')!
    await this.drawFrame(ctx)
    return canvas
  }
}
```

**ä½¿ç”¨åœºæ™¯**:
- âœ… å¯¼å‡ºå›¾ç‰‡åºåˆ—
- âœ… ç”Ÿæˆ Sprite Sheet
- âœ… å¯¼å‡º GIF åŠ¨ç”»
- âœ… å¯¼å‡ºè§†é¢‘æ–‡ä»¶

---

## ğŸ”§ ä½¿ç”¨æ–¹å¼ä¸°å¯Œ

### 1. CLI å·¥å…· â­â­â­â­â­

```typescript
// bin/lottie.ts
#!/usr/bin/env node

import { Command } from 'commander'
import { LottieOptimizer } from './optimizer'
import { LottieConverter } from './converter'

const program = new Command()

program
  .name('lottie')
  .description('Lottie animation management CLI')
  .version('1.0.0')

// ä¼˜åŒ–å‘½ä»¤
program
  .command('optimize <input>')
  .description('Optimize Lottie animation file')
  .option('-o, --output <output>', 'Output file path')
  .option('--remove-hidden', 'Remove hidden layers')
  .option('--round-values <precision>', 'Round numeric values', '2')
  .option('--compress', 'Compress output')
  .action(async (input, options) => {
    const optimizer = new LottieOptimizer()
    await optimizer.optimize(input, {
      output: options.output,
      removeHidden: options.removeHidden,
      precision: parseInt(options.roundValues),
      compress: options.compress
    })
    console.log('âœ… Optimization complete!')
  })

// è½¬æ¢å‘½ä»¤
program
  .command('convert <input>')
  .description('Convert Lottie to other formats')
  .option('-f, --format <format>', 'Output format (gif|mp4|webm|png)', 'gif')
  .option('-o, --output <output>', 'Output file path')
  .option('--fps <fps>', 'Frame rate', '30')
  .option('--scale <scale>', 'Scale factor', '1')
  .action(async (input, options) => {
    const converter = new LottieConverter()
    await converter.convert(input, {
      format: options.format,
      output: options.output,
      fps: parseInt(options.fps),
      scale: parseFloat(options.scale)
    })
    console.log('âœ… Conversion complete!')
  })

// é¢„è§ˆå‘½ä»¤
program
  .command('preview <input>')
  .description('Preview Lottie animation in browser')
  .option('-p, --port <port>', 'Server port', '3000')
  .action(async (input, options) => {
    const { PreviewServer } = await import('./preview')
    const server = new PreviewServer()
    await server.start(input, parseInt(options.port))
  })

// åˆ†æå‘½ä»¤
program
  .command('analyze <input>')
  .description('Analyze Lottie animation')
  .option('--json', 'Output as JSON')
  .action(async (input, options) => {
    const { LottieAnalyzer } = await import('./analyzer')
    const analyzer = new LottieAnalyzer()
    const report = await analyzer.analyze(input)
    
    if (options.json) {
      console.log(JSON.stringify(report, null, 2))
    } else {
      console.log('ğŸ“Š Animation Analysis:')
      console.log(`  Duration: ${report.duration}ms`)
      console.log(`  Frames: ${report.totalFrames}`)
      console.log(`  Layers: ${report.layers}`)
      console.log(`  File Size: ${report.fileSize}`)
      console.log(`  Complexity: ${report.complexity}`)
    }
  })

program.parse()
```

**åŠŸèƒ½**:
- âœ… åŠ¨ç”»æ–‡ä»¶ä¼˜åŒ–
- âœ… æ ¼å¼è½¬æ¢
- âœ… æœ¬åœ°é¢„è§ˆæœåŠ¡å™¨
- âœ… æ€§èƒ½åˆ†æ

---

### 2. å¼€å‘è€…å·¥å…·ï¼ˆDevTools Extensionï¼‰â­â­â­â­

```typescript
// src/devtools/panel.ts
export class LottieDevTools {
  private instances: Map<string, ILottieInstance> = new Map()
  private panel: HTMLElement

  constructor() {
    this.init()
  }

  private init(): void {
    // æ³¨å…¥åˆ°é¡µé¢
    this.injectInspector()
    
    // ç›‘å¬å®ä¾‹åˆ›å»º
    this.interceptInstanceCreation()
  }

  /**
   * æ³¨å…¥æ£€æŸ¥å™¨ UI
   */
  private injectInspector(): void {
    // åˆ›å»ºæ‚¬æµ®é¢æ¿
    const panel = document.createElement('div')
    panel.id = 'lottie-devtools'
    panel.innerHTML = `
      <div class="lottie-devtools-header">
        <h3>Lottie Inspector</h3>
        <button id="lottie-close">Ã—</button>
      </div>
      <div class="lottie-devtools-content">
        <div id="lottie-instance-list"></div>
        <div id="lottie-inspector"></div>
      </div>
    `
    
    document.body.appendChild(panel)
    this.panel = panel
    
    // æ·»åŠ æ ·å¼
    this.injectStyles()
  }

  /**
   * æ‹¦æˆªå®ä¾‹åˆ›å»º
   */
  private interceptInstanceCreation(): void {
    const originalCreate = lottieManager.create.bind(lottieManager)
    
    lottieManager.create = (config: LottieConfig) => {
      const instance = originalCreate(config)
      this.registerInstance(instance)
      return instance
    }
  }

  /**
   * æ³¨å†Œå®ä¾‹
   */
  private registerInstance(instance: ILottieInstance): void {
    this.instances.set(instance.id, instance)
    this.updateInstanceList()
    
    // ç›‘å¬å®ä¾‹äº‹ä»¶
    instance.on('stateChange', () => this.updateInspector(instance))
    instance.on('enterFrame', () => this.updateFrameInfo(instance))
  }

  /**
   * æ›´æ–°å®ä¾‹åˆ—è¡¨
   */
  private updateInstanceList(): void {
    const listEl = this.panel.querySelector('#lottie-instance-list')!
    
    listEl.innerHTML = Array.from(this.instances.values())
      .map(instance => `
        <div class="instance-item" data-id="${instance.id}">
          <span class="instance-name">${instance.name || instance.id}</span>
          <span class="instance-state">${instance.state}</span>
          <div class="instance-controls">
            <button onclick="window.__lottieInspect('${instance.id}')">ğŸ”</button>
            <button onclick="window.__lottiePlay('${instance.id}')">â–¶</button>
            <button onclick="window.__lottiePause('${instance.id}')">â¸</button>
          </div>
        </div>
      `)
      .join('')
  }

  /**
   * æ›´æ–°æ£€æŸ¥å™¨
   */
  private updateInspector(instance: ILottieInstance): void {
    const inspectorEl = this.panel.querySelector('#lottie-inspector')!
    
    const metrics = instance.getMetrics()
    
    inspectorEl.innerHTML = `
      <div class="inspector-section">
        <h4>Instance Info</h4>
        <table>
          <tr><td>ID:</td><td>${instance.id}</td></tr>
          <tr><td>Name:</td><td>${instance.name}</td></tr>
          <tr><td>State:</td><td>${instance.state}</td></tr>
          <tr><td>Renderer:</td><td>${instance.config.renderer}</td></tr>
        </table>
      </div>
      
      <div class="inspector-section">
        <h4>Performance</h4>
        <table>
          <tr><td>FPS:</td><td>${metrics?.fps || 0}</td></tr>
          <tr><td>Memory:</td><td>${metrics?.memory || 0} MB</td></tr>
          <tr><td>Load Time:</td><td>${metrics?.loadTime || 0} ms</td></tr>
        </table>
      </div>
      
      <div class="inspector-section">
        <h4>Animation</h4>
        <table>
          <tr><td>Duration:</td><td>${metrics?.duration || 0} ms</td></tr>
          <tr><td>Total Frames:</td><td>${metrics?.totalFrames || 0}</td></tr>
          <tr><td>Current Frame:</td><td id="current-frame">0</td></tr>
        </table>
        <input 
          type="range" 
          id="frame-slider" 
          min="0" 
          max="${metrics?.totalFrames || 0}"
          value="0"
        />
      </div>
      
      <div class="inspector-section">
        <h4>Controls</h4>
        <div class="control-group">
          <label>Speed: <span id="speed-value">1x</span></label>
          <input 
            type="range" 
            id="speed-slider" 
            min="0.1" 
            max="3" 
            step="0.1"
            value="1"
          />
        </div>
      </div>
    `
    
    // ç»‘å®šäº‹ä»¶
    this.bindInspectorEvents(instance)
  }

  /**
   * ç»‘å®šæ£€æŸ¥å™¨äº‹ä»¶
   */
  private bindInspectorEvents(instance: ILottieInstance): void {
    // å¸§æ»‘å—
    const frameSlider = this.panel.querySelector('#frame-slider') as HTMLInputElement
    frameSlider?.addEventListener('input', (e) => {
      const frame = parseInt((e.target as HTMLInputElement).value)
      instance.goToAndStop(frame, true)
    })
    
    // é€Ÿåº¦æ»‘å—
    const speedSlider = this.panel.querySelector('#speed-slider') as HTMLInputElement
    speedSlider?.addEventListener('input', (e) => {
      const speed = parseFloat((e.target as HTMLInputElement).value)
      instance.setSpeed(speed)
      this.panel.querySelector('#speed-value')!.textContent = `${speed.toFixed(1)}x`
    })
  }

  /**
   * æ›´æ–°å¸§ä¿¡æ¯
   */
  private updateFrameInfo(instance: ILottieInstance): void {
    const frameEl = this.panel.querySelector('#current-frame')
    if (frameEl && instance.animation) {
      frameEl.textContent = Math.floor(instance.animation.currentFrame).toString()
    }
  }

  /**
   * æ³¨å…¥æ ·å¼
   */
  private injectStyles(): void {
    const style = document.createElement('style')
    style.textContent = `
      #lottie-devtools {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 400px;
        max-height: 80vh;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 999999;
        overflow: auto;
      }
      
      .lottie-devtools-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        background: #f5f5f5;
        border-bottom: 1px solid #ddd;
      }
      
      .instance-item {
        padding: 8px 12px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .instance-controls button {
        margin-left: 4px;
        padding: 4px 8px;
        cursor: pointer;
      }
      
      .inspector-section {
        padding: 12px;
        border-bottom: 1px solid #eee;
      }
      
      .inspector-section table {
        width: 100%;
      }
      
      .inspector-section table td {
        padding: 4px 0;
      }
      
      .control-group {
        margin-top: 8px;
      }
      
      input[type="range"] {
        width: 100%;
      }
    `
    document.head.appendChild(style)
  }
}

// è‡ªåŠ¨åˆå§‹åŒ–
if (process.env.NODE_ENV === 'development') {
  new LottieDevTools()
}
```

**åŠŸèƒ½**:
- âœ… å®æ—¶å®ä¾‹ç›‘æ§
- âœ… æ€§èƒ½æŒ‡æ ‡æŸ¥çœ‹
- âœ… äº¤äº’å¼æ§åˆ¶
- âœ… å¸§çº§è°ƒè¯•

---

### 3. æ›´å¤šæ¡†æ¶é€‚é…å™¨ â­â­â­â­

#### Svelte é€‚é…å™¨

```typescript
// src/adapters/svelte.ts
import { writable, type Writable } from 'svelte/store'
import type { LottieConfig, ILottieInstance } from '../types'
import { lottieManager } from '../core/LottieManager'

export function useLottie(config: LottieConfig) {
  let instance: ILottieInstance | null = null
  const state: Writable<string> = writable('idle')
  const isPlaying: Writable<boolean> = writable(false)

  function init(container: HTMLElement) {
    instance = lottieManager.create({
      ...config,
      container
    })

    instance.on('stateChange', (newState) => {
      state.set(newState)
      isPlaying.set(newState === 'playing')
    })

    instance.load()

    return () => {
      instance?.destroy()
    }
  }

  return {
    init,
    state,
    isPlaying,
    play: () => instance?.play(),
    pause: () => instance?.pause(),
    stop: () => instance?.stop(),
    setSpeed: (speed: number) => instance?.setSpeed(speed),
    getInstance: () => instance
  }
}

// Svelte Component
// <script lang="ts">
//   import { useLottie } from '@ldesign/lottie/svelte'
//
//   let container: HTMLElement
//   const lottie = useLottie({
//     path: '/animation.json',
//     loop: true
//   })
//
//   $: {
//     if (container) {
//       lottie.init(container)
//     }
//   }
// </script>
//
// <div bind:this={container}></div>
// <button on:click={lottie.play}>Play</button>
```

#### Angular é€‚é…å™¨

```typescript
// src/adapters/angular.ts
import { Directive, ElementRef, Input, OnInit, OnDestroy } from '@angular/core'
import type { LottieConfig, ILottieInstance } from '../types'
import { lottieManager } from '../core/LottieManager'

@Directive({
  selector: '[lottie]'
})
export class LottieDirective implements OnInit, OnDestroy {
  @Input() lottie!: LottieConfig
  private instance: ILottieInstance | null = null

  constructor(private el: ElementRef) {}

  ngOnInit() {
    this.instance = lottieManager.create({
      ...this.lottie,
      container: this.el.nativeElement
    })
    this.instance.load()
  }

  ngOnDestroy() {
    this.instance?.destroy()
  }

  play() {
    this.instance?.play()
  }

  pause() {
    this.instance?.pause()
  }
}

// Usage:
// <div [lottie]="{ path: '/animation.json', loop: true }"></div>
```

#### Solid.js é€‚é…å™¨

```typescript
// src/adapters/solid.ts
import { createSignal, onMount, onCleanup } from 'solid-js'
import type { LottieConfig, ILottieInstance } from '../types'
import { lottieManager } from '../core/LottieManager'

export function useLottie(config: LottieConfig) {
  let containerRef: HTMLElement
  let instance: ILottieInstance | null = null
  const [state, setState] = createSignal('idle')
  const [isPlaying, setIsPlaying] = createSignal(false)

  onMount(() => {
    if (containerRef) {
      instance = lottieManager.create({
        ...config,
        container: containerRef
      })

      instance.on('stateChange', (newState) => {
        setState(newState)
        setIsPlaying(newState === 'playing')
      })

      instance.load()
    }
  })

  onCleanup(() => {
    instance?.destroy()
  })

  return {
    containerRef: (el: HTMLElement) => { containerRef = el },
    state,
    isPlaying,
    play: () => instance?.play(),
    pause: () => instance?.pause(),
    stop: () => instance?.stop(),
    getInstance: () => instance
  }
}
```

**æ”¶ç›Š**:
- âœ… æ”¯æŒæ›´å¤šä¸»æµæ¡†æ¶
- âœ… ç»Ÿä¸€çš„ API ä½“éªŒ
- âœ… ç±»å‹å®‰å…¨

---

### 4. SSR æ”¯æŒ â­â­â­â­

```typescript
// src/ssr/server.ts
export class LottieSSR {
  /**
   * æœåŠ¡å™¨ç«¯æ¸²æŸ“é¦–å¸§
   */
  static async renderFirstFrame(animationData: any, options?: {
    width?: number
    height?: number
    format?: 'svg' | 'png'
  }): Promise<string> {
    const {
      width = 400,
      height = 400,
      format = 'svg'
    } = options || {}

    if (format === 'svg') {
      // ä½¿ç”¨ lottie-node æˆ–ç±»ä¼¼åº“åœ¨æœåŠ¡å™¨ç«¯æ¸²æŸ“
      return this.renderSVG(animationData, width, height)
    } else {
      // ä½¿ç”¨ canvas åœ¨ Node.js ä¸­æ¸²æŸ“
      return this.renderPNG(animationData, width, height)
    }
  }

  /**
   * æ¸²æŸ“ä¸º SVG
   */
  private static renderSVG(data: any, width: number, height: number): string {
    // æå–ç¬¬ä¸€å¸§çš„ SVG
    // ç®€åŒ–å®ç°
    return `<svg width="${width}" height="${height}">...</svg>`
  }

  /**
   * æ¸²æŸ“ä¸º PNG
   */
  private static async renderPNG(data: any, width: number, height: number): Promise<string> {
    // ä½¿ç”¨ node-canvas æ¸²æŸ“
    const { createCanvas } = await import('canvas')
    const canvas = createCanvas(width, height)
    // æ¸²æŸ“é€»è¾‘...
    return canvas.toDataURL()
  }

  /**
   * ç”Ÿæˆå ä½ç¬¦
   */
  static generatePlaceholder(config: LottieConfig): string {
    return `
      <div 
        data-lottie-placeholder 
        data-config='${JSON.stringify(config)}'
        style="width: ${config.style?.width || '100%'}; height: ${config.style?.height || 'auto'};"
      >
        <noscript>
          <p>Please enable JavaScript to view this animation.</p>
        </noscript>
      </div>
    `
  }

  /**
   * æ°´åˆè„šæœ¬
   */
  static getHydrationScript(): string {
    return `
      <script>
        document.addEventListener('DOMContentLoaded', () => {
          const placeholders = document.querySelectorAll('[data-lottie-placeholder]')
          placeholders.forEach(placeholder => {
            const config = JSON.parse(placeholder.dataset.config)
            const instance = createLottie({
              ...config,
              container: placeholder
            })
          })
        })
      </script>
    `
  }
}

// Next.js ä½¿ç”¨ç¤ºä¾‹
// export async function getServerSideProps() {
//   const firstFrame = await LottieSSR.renderFirstFrame(animationData)
//   return { props: { firstFrame } }
// }
```

**æ”¶ç›Š**:
- âœ… SEO å‹å¥½
- âœ… æ›´å¿«çš„é¦–å±æ¸²æŸ“
- âœ… æ¸è¿›å¢å¼º

---

## ğŸ—ï¸ æ¶æ„ä¼˜åŒ–å»ºè®®

### 1. æ’ä»¶ç³»ç»Ÿ â­â­â­â­â­

```typescript
// src/core/PluginSystem.ts
export interface LottiePlugin {
  name: string
  version: string
  install: (manager: LottieManager, options?: any) => void
  uninstall?: () => void
}

export class PluginManager {
  private plugins = new Map<string, LottiePlugin>()
  private installedPlugins = new Set<string>()

  /**
   * æ³¨å†Œæ’ä»¶
   */
  register(plugin: LottiePlugin): void {
    if (this.plugins.has(plugin.name)) {
      console.warn(`[PluginManager] Plugin "${plugin.name}" already registered`)
      return
    }
    
    this.plugins.set(plugin.name, plugin)
  }

  /**
   * å®‰è£…æ’ä»¶
   */
  install(pluginName: string, options?: any): void {
    const plugin = this.plugins.get(pluginName)
    
    if (!plugin) {
      throw new Error(`Plugin "${pluginName}" not found`)
    }

    if (this.installedPlugins.has(pluginName)) {
      console.warn(`[PluginManager] Plugin "${pluginName}" already installed`)
      return
    }

    plugin.install(lottieManager, options)
    this.installedPlugins.add(pluginName)
  }

  /**
   * å¸è½½æ’ä»¶
   */
  uninstall(pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    
    if (!plugin) return

    plugin.uninstall?.()
    this.installedPlugins.delete(pluginName)
  }

  /**
   * è·å–å·²å®‰è£…æ’ä»¶
   */
  getInstalledPlugins(): string[] {
    return Array.from(this.installedPlugins)
  }
}

// æ’ä»¶ç¤ºä¾‹
export const analyticsPlugin: LottiePlugin = {
  name: 'analytics',
  version: '1.0.0',
  install: (manager, options) => {
    const originalCreate = manager.create.bind(manager)
    
    manager.create = (config) => {
      const instance = originalCreate(config)
      
      // æ·»åŠ åˆ†æè·Ÿè¸ª
      instance.on('play', () => {
        options.trackEvent('lottie_play', { id: instance.id })
      })
      
      instance.on('complete', () => {
        options.trackEvent('lottie_complete', { id: instance.id })
      })
      
      return instance
    }
  }
}

// ä½¿ç”¨
// pluginManager.register(analyticsPlugin)
// pluginManager.install('analytics', { trackEvent: (name, data) => {...} })
```

**æ”¶ç›Š**:
- âœ… å¯æ‰©å±•æ€§æå¼º
- âœ… åŠŸèƒ½æ¨¡å—åŒ–
- âœ… ç¬¬ä¸‰æ–¹é›†æˆå®¹æ˜“

---

## ğŸ“ˆ å®æ–½ä¼˜å…ˆçº§

### ğŸ”´ é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰

1. **Web Worker é›†æˆ** - æ€§èƒ½æå‡æœ€æ˜æ˜¾
2. **æ™ºèƒ½å†…å­˜ç®¡ç†** - é˜²æ­¢å´©æºƒ
3. **è™šæ‹ŸåŒ–æ¸²æŸ“** - å¤§å¹…å‡å°‘èµ„æºæ¶ˆè€—
4. **èµ„æºæ¸…ç†å¢å¼º** - ä¿®å¤å†…å­˜æ³„æ¼

### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ï¼ˆ1-2ä¸ªæœˆå†…ï¼‰

5. **æ‰¹é‡æ¸²æŸ“ä¼˜åŒ–** - æå‡å¤šå®ä¾‹æ€§èƒ½
6. **å¸§ç‡è‡ªé€‚åº”** - æ”¹å–„ä½ç«¯è®¾å¤‡ä½“éªŒ
7. **å‹ç¼©å­˜å‚¨** - èŠ‚çœå†…å­˜
8. **CLI å·¥å…·** - æ”¹å–„å¼€å‘ä½“éªŒ

### ğŸŸ¢ ä½ä¼˜å…ˆçº§ï¼ˆ3-6ä¸ªæœˆå†…ï¼‰

9. **åŠ¨ç”»ç¼–è¾‘å™¨** - é«˜çº§åŠŸèƒ½
10. **DevTools æ‰©å±•** - è°ƒè¯•å·¥å…·
11. **æ›´å¤šæ¡†æ¶é€‚é…å™¨** - ç”Ÿæ€æ‰©å±•
12. **SSR æ”¯æŒ** - ç‰¹å®šåœºæ™¯éœ€æ±‚

---

## ğŸ¯ é¢„æœŸæ”¶ç›Š

### æ€§èƒ½æå‡
- âœ… ä¸»çº¿ç¨‹é˜»å¡å‡å°‘ **60-80%**
- âœ… å¤§æ–‡ä»¶åŠ è½½é€Ÿåº¦æå‡ **3-5å€**
- âœ… å¤šå®ä¾‹æ¸²æŸ“å¸§ç‡æå‡ **40-50%**
- âœ… æ»šåŠ¨æ€§èƒ½æå‡ **80%**
- âœ… ä½ç«¯è®¾å¤‡æµç•…åº¦æå‡ **100%**

### å†…å­˜ä¼˜åŒ–
- âœ… å†…å­˜å ç”¨å‡å°‘ **40-70%**
- âœ… ç¼“å­˜ç©ºé—´èŠ‚çœ **60-80%**
- âœ… å†…å­˜æº¢å‡ºé£é™©é™ä½ **90%**
- âœ… GC å‹åŠ›å‡å°‘ **50%**

### åŠŸèƒ½å®Œå–„
- âœ… åŠŸèƒ½æ•°é‡å¢åŠ  **200%**
- âœ… ä½¿ç”¨åœºæ™¯æ‰©å±• **300%**
- âœ… å¼€å‘ä½“éªŒæå‡ **æ˜¾è‘—**
- âœ… ç”Ÿæ€ç³»ç»Ÿå®Œå–„åº¦ **å¤§å¹…æé«˜**

### ä½¿ç”¨ä½“éªŒ
- âœ… æ¡†æ¶æ”¯æŒå¢åŠ  **100%** (æ–°å¢3ä¸ª)
- âœ… è°ƒè¯•æ•ˆç‡æå‡ **500%**
- âœ… éƒ¨ç½²çµæ´»æ€§æå‡ **æ˜¾è‘—**
- âœ… å­¦ä¹ æ›²çº¿é™ä½ **30%**

---

## ğŸ“ æ€»ç»“

è¿™ä¸ª Lottie åº“å·²ç»å…·å¤‡äº†éå¸¸å®Œå–„çš„åŸºç¡€åŠŸèƒ½å’Œæ€§èƒ½ä¼˜åŒ–ï¼Œä½†ä»æœ‰å¾ˆå¤§çš„ä¼˜åŒ–ç©ºé—´ï¼š

### å½“å‰ä¼˜åŠ¿
âœ… æ ¸å¿ƒåŠŸèƒ½å®Œæ•´ã€æ¶æ„æ¸…æ™°  
âœ… å·²æœ‰æ€§èƒ½ä¼˜åŒ–æªæ–½  
âœ… ä¸°å¯Œçš„é«˜çº§åŠŸèƒ½  
âœ… è‰¯å¥½çš„ç±»å‹æ”¯æŒ

### æ”¹è¿›æ–¹å‘
ğŸš€ **æ€§èƒ½**: Web Workerã€è™šæ‹ŸåŒ–ã€æ‰¹é‡æ¸²æŸ“  
ğŸ’¾ **å†…å­˜**: æ™ºèƒ½ç®¡ç†ã€å‹ç¼©å­˜å‚¨ã€å¯¹è±¡æ±   
ğŸ¨ **åŠŸèƒ½**: ç¼–è¾‘å™¨ã€æ—¶é—´è½´ã€åˆæˆå™¨  
ğŸ”§ **å·¥å…·**: CLIã€DevToolsã€æ›´å¤šé€‚é…å™¨

### å®æ–½å»ºè®®
1. **ä¼˜å…ˆå®æ–½é«˜ä¼˜å…ˆçº§é¡¹ç›®**ï¼ˆæ€§èƒ½å’Œå†…å­˜ç›¸å…³ï¼‰
2. **é€æ­¥æ·»åŠ æ–°åŠŸèƒ½**ï¼ˆé¿å…è¿‡åº¦å¤æ‚ï¼‰
3. **ä¿æŒå‘åå…¼å®¹**ï¼ˆæ¸è¿›å¼å‡çº§ï¼‰
4. **å®Œå–„æµ‹è¯•è¦†ç›–**ï¼ˆç¡®ä¿è´¨é‡ï¼‰
5. **æŒç»­æ€§èƒ½ç›‘æ§**ï¼ˆæ•°æ®é©±åŠ¨ä¼˜åŒ–ï¼‰

é€šè¿‡ç³»ç»Ÿæ€§åœ°å®æ–½è¿™äº›ä¼˜åŒ–ï¼Œå¯ä»¥å°†è¿™ä¸ªåº“æ‰“é€ æˆä¸šç•Œæœ€å¼ºçš„ Lottie è§£å†³æ–¹æ¡ˆï¼ğŸ‰


